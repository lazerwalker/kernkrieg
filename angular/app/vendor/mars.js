// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

window.mars = (function (modules) {
	var resolve, getRequire, require, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]};
	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullpath, state) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
			} else {
				tree.push(scope);
				scope = scope[dir];
			}
			if (!scope) throw notFoundError(fullpath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullpath, 1);
			}
			return resolve(scope, tree, 'index', fullpath, 2);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullpath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports };
		fn.call(exports, exports, module, getRequire(scope, tree));
		return module.exports;
	};
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) throw notFoundError(fullpath);
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullpath, state);
	};
	getRequire = function (scope, tree) {
		return function (path) { return require(scope, [].concat(tree), path); };
	};
	return getRequire(modules, []);
})({
	"client": {
		"frontend.js": function (exports, module, require) {
			exports.redcode = require('./redcode-asm.js');
			exports.MARS = require('./mars.js');
		},
		"instruction.js": function (exports, module, require) {
			module.exports = (function(){

			    Array.prototype.randomElement = function()
			    {
			        return this[Math.floor(Math.random() * this.length)];
			    }

			    var Instruction = function Instruction(labels,operation,aoperand,boperand)
			    {
			        this.labels = labels;
			        this.opcode = operation.opcode;
			        this.modifier = operation.modifier;
			        this.aoperand = aoperand;
			        this.boperand = boperand;

			        this.equal = function(other)
			        {
			            if(this.modifier !== other.modifier)
			                return false;
			            if(this.opcode !== other.opcode)
			                return false;

			            if(this.aoperand[0] !== other.aoperand[0])
			                return false;
			            if(this.boperand[0] !== other.boperand[0])
			                return false;

			            if(this.aoperand[1] !== other.aoperand[1])
			                return false;
			            if(this.boperand[1] !== other.boperand[1])
			                return false;
			            return true;
			        }

			        this.toString = function()
			        {
			            var res = this.opcode;
			            if(this.modifier == "ab" ||
			               this.modifier == "ba")
			                res += "." + this.modifier;
			            else if(this.modifier)
			                res += "." + this.modifier + " ";
			            else
			                res += "   ";
			            res += " ";
			            if(this.aoperand)
			                res += this.aoperand.join("");

			            if(this.boperand)
			                res += ", " + this.boperand.join("");
			            return res;
			        };
			    }

			    Instruction.directInstruction = function(opcode)
			    {
			        return new Instruction([],
			        {opcode: opcode, modifier: ""}, ["",0], ["",0]);
			    }

			    Instruction.randomInstruction = function(coreSize)
			    {
			        return new Instruction([],
			            {opcode: Instruction.opcodes.randomElement(),
			             modifier: Instruction.modifiers.randomElement()},
			            [Instruction.addressModes.randomElement(),
			             Math.floor(Math.random()*coreSize)],
			            [Instruction.addressModes.randomElement(),
			             Math.floor(Math.random()*coreSize)]);
			    }

			    Instruction.opcodes = [
			        "dat",
			        "mov",
			        "add",
			        "sub",
			        "mul",
			        "div",
			        "mod",
			        "jmp",
			        "jmz",
			        "jmn",
			        "djn",
			        "cmp",
			        "spl",
			        "seq",
			        "sne",
			        "slt",
			        "nop",
			        "ldp",
			        "stp"];

			    Instruction.opcodesStrict94 = [
			        "dat",
			        "mov",
			        "add",
			        "sub",
			        "mul",
			        "div",
			        "mod",
			        "jmp",
			        "jmz",
			        "jmn",
			        "djn",
			        "cmp",
			        "slt",
			        "spl"];

			    Instruction.modifiers = ["ab","ba","a","b","f","x","i"];
			    Instruction.addressModes = ["#","$","@","<",">","*","{","}"];
			    Instruction.addressModesStrict94 = ["#","$","@","<",">"];


			    return Instruction;
			})();
		},
		"mars.js": function (exports, module, require) {
			module.exports = (function(){
			    var redcodeAsm = require('./redcode-asm.js');
			    var redcodeParser = require('./redcode-asm-parser.js');
			    
			    var sprintf = require("sprintf-js").sprintf;
			    var Instruction = require("./instruction.js");

			    var clone = function(obj) {
			        // Handle the 3 simple types, and null or undefined
			        if (null == obj || "object" != typeof obj) return obj;

			        // Handle Date
			        if (obj instanceof Date) {
			            var copy = new Date();
			            copy.setTime(obj.getTime());
			            return copy;
			        }

			        // Handle Array
			        if (obj instanceof Array) {
			            var copy = [];
			            for (var i = 0, len = obj.length; i < len; i++) {
			                copy[i] = clone(obj[i]);
			            }
			            return copy;
			        }

			        // Handle Object
			        if (obj instanceof Object) {
			            var copy = {};
			            for (var attr in obj) {
			                if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
			            }
			            return copy;
			        }

			        throw new Error("Unable to copy obj! Its type isn't supported.");
			    };

			    var MARS = function(coreSize,
			        pSpaceSize,
			        cyclesUntilTie,
			        initialInstruction,
			        instructionLimit,
			        maxTasks,
			        minSep,
			        initialSep,
			        readDist,
			        writeDist)
			    {
			        if(readDist == MARS.full)
			            readDist = coreSize;

			        if(writeDist == MARS.full)
			            writeDist = coreSize;

			        this.coreSize = coreSize;
			        this.pSpaceSize = pSpaceSize;
			        this.cyclesUntilTie = cyclesUntilTie;
			        this.initialInstruction = initialInstruction;
			        this.instructionLimit = instructionLimit;
			        this.maxTasks = maxTasks;
			        this.curMaxTasks = 0;
			        this.minSep = minSep;
			        this.initialSep = initialSep;
			        this.readDist = readDist;
			        this.writeDist = writeDist;
			        this.loadedWarriors = 0;
			        this.loadedWarriorsLength = 0;
			        this.activeWarriors = 0;
			        this.currentWarrior = 0;
			        this.taskQueues = [];
			        this.pSpaces = [];

			        if(coreSize % pSpaceSize !== 0)
			            throw new Error("PSpace size needs two be a factor of the size of the Core");

			        if(coreSize % readDist !== 0)
			            throw new Error("Read distance needs two be a factor of the size of the Core");

			        if(coreSize % writeDist !== 0)
			            throw new Error("Write distance needs two be a factor of the size of the Core");


			        this.coreOwner = [];
			        this.core = [];
			        for(var i=0;i<coreSize;i++)
			        {
			            if(typeof initialInstruction == "string")
			            {
			                this.core.push(Instruction.randomInstruction(coreSize));
			            }
			            else
			            {
			                this.core.push(clone(initialInstruction));
			            }
			            this.coreOwner.push(-1);
			        }
			    };



			    MARS.prototype.reset = function()
			    {

			    };

			    MARS.prototype.loadWarrior = function(program, pSpaceZero)
			    {
			        var loadAddress = 0;
			        if(this.taskQueues.length)
			            loadAddress += _.last(this.taskQueues)[0];


			        var loadLength = Math.min(this.instructionLimit, program.instructions.length);


			        if(this.initialSep == MARS.random)
			        {
			            loadAddress += this.minSep +
			                Math.floor(Math.random() * (this.coreSize-
			                    this.minSep-this.loadedWarriorsLength-loadLength));
			        }
			        else
			        {
			            loadAddress += this.initialSep;
			        }

			        this.currentWarrior = this.loadedWarriors;

			        for(var i=0;i<loadLength;i++)
			        {
			            var instruction = program.instructions[i];
			            if(instruction.aoperand)
			            {
			                instruction.aoperand[1] = this.address(instruction.aoperand[1]);
			                if(instruction.aoperand[0] == '$')
			                    instruction.aoperand[0] = '';
			            }
			            if(instruction.boperand)
			            {
			                instruction.boperand[1] = this.address(instruction.boperand[1]);
			                if(instruction.boperand[0] == '$')
			                    instruction.boperand[0] = '';
			            }
			            this.setInstruction(loadAddress + i, instruction);
			        }
			        this.loadedWarriors++;
			        this.activeWarriors++;

			        this.loadedWarriorsLength += program.instructions.length;
			        this.taskQueues.push([this.address(loadAddress+program.origin)]);

			        if(this.curMaxTasks == 0)
			            this.curMaxTasks = 1;

			        var pSpace = [];
			        for(var i=0;i<this.pSpaceSize;i++)
			            pSpace.push(pSpaceZero);
			        this.pSpaces.push(pSpace);
			    };

			    MARS.prototype.run = function(minWarriors, debugOutput, debugResolution)
			    {
			        var curCycle = 0;
			        while(curCycle < this.cyclesUntilTie && this.activeWarriors > minWarriors)
			        {
			            this.cycle();

			            if(curCycle % debugResolution == 0)
			            {
			                if(debugOutput == 1)
			                {
			                    console.log(sprintf("Cycle %u", curCycle));
			                    console.log(this.taskQueues);
			                }
			                if(debugOutput == 2)
			                {
			                    console.log(sprintf("################### Cycle %u ###################", curCycle));
			                    console.log(this.coreDump());
			                }
			            }

			            curCycle++;
			        }

			        if(debugOutput == 1)
			        {
			            console.log(sprintf("Cycle %u", curCycle));
			            console.log(this.taskQueues);
			        }
			        if(debugOutput == 2)
			        {
			            console.log(sprintf("################### Cycle %u ###################", curCycle));
			            console.log(this.coreDump());
			        }



			        if(curCycle == this.cyclesUntilTie)
			            return -1;

			        for(var w=0;w<this.loadedWarriors;w++)
			            if(this.taskQueues[w].length > 0)
			                return w;

			        return -2;
			    };


			    MARS.prototype.address = function(integer)
			    {
			        while(integer < 0)
			        {
			            integer += this.coreSize;
			        }
			        return integer % this.coreSize;
			    }

			    MARS.prototype.setInstruction = function(adr, instruction)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        this.core[this.address(adr)] = clone(instruction);
			    }

			    MARS.prototype.setOperand = function(adr, isAValue, value)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        if(isAValue)
			            this.core[this.address(adr)].aoperand[1] = this.address(value);
			        else
			            this.core[this.address(adr)].boperand[1] = this.address(value);
			    }


			    MARS.prototype.decrementOperand = function(adr, isAValue)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        if(isAValue)
			            this.core[this.address(adr)].aoperand[1]--;
			        else
			            this.core[this.address(adr)].boperand[1]--;
			    }

			    MARS.prototype.getInstruction = function(adr)
			    {
			        return clone(this.core[this.address(adr)]);
			    }

			    MARS.prototype.incrementA = function(adr)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        return this.core[this.address(adr)].aoperand[1]++;
			    }

			    MARS.prototype.incrementB = function(adr)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        return this.core[this.address(adr)].boperand[1]++;
			    }

			    MARS.prototype.decrementA = function(adr)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        return this.core[this.address(adr)].aoperand[1]--;
			    }

			    MARS.prototype.decrementB = function(adr)
			    {
			        this.coreOwner[this.address(adr)] = this.currentWarrior;
			        return this.core[this.address(adr)].boperand[1]--;
			    }


			    MARS.prototype.evaluateOperand = function(pc, operand)
			    {
			        var addressMode = operand[0];

			        switch(addressMode)
			        {
			        case "#":
			            return pc;
			        case "":
			        case "$":
			            return pc+operand[1];
			        case "*":
			            return pc+operand[1]+this.getInstruction(pc+operand[1]).aoperand[1];
			        case "@":
			            return pc+operand[1]+this.getInstruction(pc+operand[1]).boperand[1];
			        case "{":
			            this.decrementA(pc+operand[1]);
			            return pc+operand[1]+this.getInstruction(pc+operand[1]).aoperand[1];
			        case "}":
			            var res =  pc+operand[1]+this.getInstruction(pc+operand[1]).aoperand[1];
			            this.incrementA(pc+operand[1]);
			            return res;
			        case "<":
			            this.decrementB(pc+operand[1]);
			            return pc+operand[1]+this.getInstruction(pc+operand[1]).boperand[1];
			        case ">":
			            var res =  pc+operand[1]+this.getInstruction(pc+operand[1]).boperand[1];
			            this.incrementB(pc+operand[1]);
			            return res;
			        }
			    }


			    MARS.prototype.cycle = function()
			    {
			        // Get the current task pointer
			        var cw = this.currentWarrior;
			        var pc = this.taskQueues[cw].shift();
			        var instruction = this.getInstruction(pc);

			        // Evaluate A-Operand
			        var apointer = this.evaluateOperand(pc, instruction.aoperand);
			        var ainstruction = this.getInstruction(apointer);

			        // Evaluate B-Operand
			        var bpointer = this.evaluateOperand(pc, instruction.boperand);
			        var binstruction = this.getInstruction(bpointer);

			        if(instruction.modifier == "")
			        {
			            switch(instruction.opcode)
			            {
			            case "dat":
			            case "nop":
			                instruction.modifier = "f";
			                break;
			            case "mov":
			            case "cmp":
			            case "seq":
			            case "sne":
			                if(instruction.aoperand[0] == "#")
			                {
			                    instruction.modifier = "ab";
			                    break;
			                }
			                if(instruction.boperand[0] == "#")
			                {
			                    instruction.modifier = "b";
			                    break;
			                }
			                instruction.modifier = "i";
			                break;
			            case "add":
			            case "sub":
			            case "mul":
			            case "div":
			            case "mod":
			                if(instruction.aoperand[0] == "#")
			                {
			                    instruction.modifier = "ab";
			                    break;
			                }
			                if(instruction.boperand[0] == "#")
			                {
			                    instruction.modifier = "b";
			                    break;
			                }
			                instruction.modifier = "f";
			                break;
			            case "slt":
			            case "ldp":
			            case "stp":
			                if(instruction.aoperand[0] == "#")
			                {
			                    instruction.modifier = "ab";
			                    break;
			                }
			                instruction.modifier = "b";
			                break;
			            case "jmp":
			            case "spl":
			            case "jmz":
			            case "jmn":
			            case "djn":
			                instruction.modifier = "b";
			                break;
			            default:
			                break;
			            }
			        }

			        if(instruction.modifier == "i" &&
			           instruction.opcode != "mov" &&
			           instruction.opcode != "seq" &&
			           instruction.opcode != "sne" &&
			           instruction.opcode != "cmp")
			            instruction.modifier = "f";

			        var avalue = 0;
			        var bvalue = 0;
			        var writePointer;
			        var writeA;

			        switch(instruction.modifier)
			        {
			            case "a":
			                avalue = [ainstruction.aoperand[1]];
			                bvalue = [binstruction.aoperand[1]];
			                writePointer = [bpointer];
			                writeA = [true];
			                break;
			            case "b":
			                avalue = [ainstruction.boperand[1]];
			                bvalue = [binstruction.boperand[1]];
			                writePointer = [bpointer];
			                writeA = [false];
			                break;
			            case "ab":
			                avalue = [ainstruction.aoperand[1]];
			                bvalue = [binstruction.boperand[1]];
			                writePointer = [bpointer];
			                writeA = [false];
			                break;
			            case "ba":
			                avalue = [ainstruction.boperand[1]];
			                bvalue = [binstruction.aoperand[1]];
			                writePointer = [bpointer];
			                writeA = [true];
			                break;
			            case "f":
			                avalue = [ainstruction.aoperand[1],ainstruction.boperand[1]];
			                bvalue = [binstruction.aoperand[1],binstruction.boperand[1]];
			                writePointer = [bpointer, bpointer];
			                writeA = [true, false];
			                break;
			            case "x":
			                avalue = [ainstruction.aoperand[1],ainstruction.boperand[1]];
			                bvalue = [binstruction.boperand[1],binstruction.aoperand[1]];
			                writePointer = [bpointer, bpointer];
			                writeA = [false, true];
			                break;
			            case "i":
			                avalue = ainstruction;
			                bvalue = binstruction;
			                writePointer = [bpointer];
			                writeA = ["instruction"];
			                break;
			        }

			        var pushToQueue = true;
			        var split = false;
			        var splitPC = pc + 1;
			        var newPC = pc + 1;


			        for(var i=0;i<writePointer.length;i++)
			        {
			            switch(instruction.opcode)
			            {
			            case "dat":
			                // Remove warrior from queue
			                pushToQueue = false;
			                break;
			            case "mov":
			                if(writeA[i] == "instruction")
			                {
			                    this.core[this.address(writePointer[i])] = avalue;
			                    this.coreOwner[this.address(writePointer[i])] = cw;
			                }
			                else
			                {
			                    this.setOperand(writePointer[i],writeA[i], avalue[i]);
			                }
			                break;
			            case "add":
			                this.setOperand(writePointer[i],writeA[i], avalue[i]+bvalue[i]);
			                break;
			            case "sub":
			                this.setOperand(writePointer[i],writeA[i], bvalue[i]-avalue[i]);
			                break;
			            case "mul":
			                this.setOperand(writePointer[i],writeA[i], avalue[i]*bvalue[i]);
			                break;
			            case "div":
			                if(avalue[i] === 0)
			                {
			                    pushToQueue = false;
			                    break;
			                }
			                this.setOperand(writePointer[i],writeA[i], bvalue[i]/avalue[i]);
			                break;
			            case "mod":
			                if(avalue[i] === 0)
			                {
			                    pushToQueue = false;
			                    break;
			                }
			                this.setOperand(writePointer[i],writeA[i], bvalue[i]%avalue[i]);
			                break;
			            case "jmp":
			                newPC = apointer;
			                break;
			            case "jmz":
			                if(bvalue[i]===0 && (i==0 || newPC == apointer))
			                    newPC = apointer;
			                else
			                    newPC = pc+1;
			                break;
			            case "jmn":
			                if(bvalue[i]!==0)
			                    newPC = apointer;
			                break;
			            case "djn":
			                bvalue[i]--;
			                this.decrementOperand(writePointer[i],writeA[i]);
			                if(bvalue[i]!==0)
			                    newPC = apointer;
			                break;
			            case "cmp":
			            case "seq":
			                if(writeA[i] == "instruction")
			                {
			                    if(avalue.equal(bvalue))
			                        newPC = pc+2;
			                    else
			                        newPC = pc+1;
			                }
			                else
			                {
			                    if(avalue[i] == bvalue[i] && (i==0 || newPC == pc+2))
			                        newPC = pc+2;
			                    else
			                        newPC = pc+1;
			                }
			                break;
			            case "sne":
			                if(avalue[i] !== bvalue[i])
			                    newPC = pc+2;
			                break;
			            case "slt":
			                if(avalue[i] < bvalue[i])
			                    newPC = pc+2;
			                break;
			            case "spl":
			                split = true;
			                splitPC = apointer;

			            case "nop":
			                break;
			            case "ldp":
			                if(i==0)
			                {
			                    this.setOperand(writePointer[i],writeA[i],
			                        this.pSpaces[cw][avalue[i]%this.pSpaceSize]);
			                }
			                break;
			            case "stp":
			                if(i==0 && bvalue[i] != 0)
			                {
			                    this.pSpaces[cw][bvalue[i]%this.pSpaceSize] = avalue;
			                }
			                break;
			            default:
			                throw new Error("Encountered unknown opcode.");
			            }
			        }

			        if(pushToQueue)
			            this.taskQueues[cw].push(this.address(newPC));
			        else if(this.taskQueues[cw].length == this.curMaxTasks)
			            this.curMaxTasks--;

			        if(split && this.taskQueues[cw].length < this.maxTasks)
			        {
			            this.taskQueues[cw].push(this.address(splitPC));
			            if(this.taskQueues[cw].length > this.curMaxTasks)
			                this.curMaxTasks++;
			        }

			        if(this.taskQueues[cw].length == 0)
			            this.activeWarriors--;

			        do
			        {
			            this.currentWarrior++;
			            if(this.currentWarrior>=this.loadedWarriors)
			                this.currentWarrior = 0;
			        } while(this.taskQueues[this.currentWarrior].length == 0 && this.currentWarrior != cw);
			    };

			    MARS.prototype.coreDump = function()
			    {
			        var dump = ["======== MARS CORE DUMP ========"];
			        dump.push("Loaded Warriors: " + this.loadedWarriors);
			        dump.push("Active Warriors: " + this.activeWarriors);
			        dump.push("Current Warrior: " + this.currentWarrior);
			        dump.push("----------- PSPACES ------------");
			        for(var i=0;i<this.pSpaces.length;i++)
			        {
			            dump.push(i + ": " + this.pSpaces[i].join(" "));
			        }
			        dump.push("------------ CORE --------------");
			        for(var i=0;i<this.coreSize;i++)
			        {
			            var l = "";
			            for(var w=0;w<this.loadedWarriors;w++)
			            {
			                var warriorIsHere = false;
			                var tasks = [];
			                for(var t=0;t<this.taskQueues[w].length;t++)
			                {
			                    if(this.taskQueues[w][t] == i)
			                    {
			                        warriorIsHere = true;
			                        tasks.push(t);
			                    }
			                }
			                if(warriorIsHere)
			                {
			                    l += w + ":";
			                    for(var t=0;t<tasks.length;t++)
			                        l += tasks[t] + ">";
			                }
			            }

			            for(var j=l.length;j<(this.curMaxTasks*2+3)*this.activeWarriors;j++)
			                l = l + " ";

			            dump.push(sprintf("%s %03u (%2d) %s", l, i, this.coreOwner[i], this.core[i].toString()));
			        }
			        dump.push("======= END OF CORE DUMP =======");
			        return dump.join("\n");
			    };

			    MARS.Instruction = Instruction;
			    MARS.random = "random";
			    MARS.full = "full";
			    MARS.none = "none";


			    return MARS;
			})();
		},
		"redcode-asm-parser.js": function (exports, module, require) {
			module.exports = (function(){
			  /*
			   * Generated by PEG.js 0.7.0.
			   *
			   * http://pegjs.majda.cz/
			   */
			  
			  function quote(s) {
			    /*
			     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
			     * string literal except for the closing quote character, backslash,
			     * carriage return, line separator, paragraph separator, and line feed.
			     * Any character may appear in the form of an escape sequence.
			     *
			     * For portability, we also escape escape all control and non-ASCII
			     * characters. Note that "\0" and "\v" escape sequences are not used
			     * because JSHint does not like the first and IE the second.
			     */
			     return '"' + s
			      .replace(/\\/g, '\\\\')  // backslash
			      .replace(/"/g, '\\"')    // closing quote character
			      .replace(/\x08/g, '\\b') // backspace
			      .replace(/\t/g, '\\t')   // horizontal tab
			      .replace(/\n/g, '\\n')   // line feed
			      .replace(/\f/g, '\\f')   // form feed
			      .replace(/\r/g, '\\r')   // carriage return
			      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
			      + '"';
			  }
			  
			  var result = {
			    /*
			     * Parses the input with a generated parser. If the parsing is successfull,
			     * returns a value explicitly or implicitly specified by the grammar from
			     * which the parser was generated (see |PEG.buildParser|). If the parsing is
			     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
			     */
			    parse: function(input, startRule) {
			      var parseFunctions = {
			        "list": parse_list,
			        "line": parse_line,
			        "comment": parse_comment,
			        "instruction": parse_instruction,
			        "label": parse_label,
			        "label_list": parse_label_list,
			        "label_name": parse_label_name,
			        "operation": parse_operation,
			        "opcode": parse_opcode,
			        "modifier": parse_modifier,
			        "mode_expr": parse_mode_expr,
			        "mode": parse_mode,
			        "expr": parse_expr,
			        "expr_op": parse_expr_op,
			        "term": parse_term,
			        "number": parse_number,
			        "signed_integer": parse_signed_integer,
			        "natural_number": parse_natural_number
			      };
			      
			      if (startRule !== undefined) {
			        if (parseFunctions[startRule] === undefined) {
			          throw new Error("Invalid rule name: " + quote(startRule) + ".");
			        }
			      } else {
			        startRule = "list";
			      }
			      
			      var pos = 0;
			      var reportFailures = 0;
			      var rightmostFailuresPos = 0;
			      var rightmostFailuresExpected = [];
			      
			      function padLeft(input, padding, length) {
			        var result = input;
			        
			        var padLength = length - input.length;
			        for (var i = 0; i < padLength; i++) {
			          result = padding + result;
			        }
			        
			        return result;
			      }
			      
			      function escape(ch) {
			        var charCode = ch.charCodeAt(0);
			        var escapeChar;
			        var length;
			        
			        if (charCode <= 0xFF) {
			          escapeChar = 'x';
			          length = 2;
			        } else {
			          escapeChar = 'u';
			          length = 4;
			        }
			        
			        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
			      }
			      
			      function matchFailed(failure) {
			        if (pos < rightmostFailuresPos) {
			          return;
			        }
			        
			        if (pos > rightmostFailuresPos) {
			          rightmostFailuresPos = pos;
			          rightmostFailuresExpected = [];
			        }
			        
			        rightmostFailuresExpected.push(failure);
			      }
			      
			      function parse_list() {
			        var result0, result1, result2;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_line();
			        if (result0 !== null) {
			          if (input.charCodeAt(pos) === 10) {
			            result2 = "\n";
			            pos++;
			          } else {
			            result2 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"\\n\"");
			            }
			          }
			          if (result2 !== null) {
			            result1 = [];
			            while (result2 !== null) {
			              result1.push(result2);
			              if (input.charCodeAt(pos) === 10) {
			                result2 = "\n";
			                pos++;
			              } else {
			                result2 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"\\n\"");
			                }
			              }
			            }
			          } else {
			            result1 = null;
			          }
			          if (result1 !== null) {
			            result2 = parse_list();
			            if (result2 !== null) {
			              result0 = [result0, result1, result2];
			            } else {
			              result0 = null;
			              pos = pos1;
			            }
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, l, lst) { return [l].concat(lst)})(pos0, result0[0], result0[2]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        if (result0 === null) {
			          pos0 = pos;
			          pos1 = pos;
			          result0 = parse_line();
			          if (result0 !== null) {
			            result1 = [];
			            if (input.charCodeAt(pos) === 10) {
			              result2 = "\n";
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("\"\\n\"");
			              }
			            }
			            while (result2 !== null) {
			              result1.push(result2);
			              if (input.charCodeAt(pos) === 10) {
			                result2 = "\n";
			                pos++;
			              } else {
			                result2 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"\\n\"");
			                }
			              }
			            }
			            if (result1 !== null) {
			              result0 = [result0, result1];
			            } else {
			              result0 = null;
			              pos = pos1;
			            }
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			          if (result0 !== null) {
			            result0 = (function(offset, l) { return [l];})(pos0, result0[0]);
			          }
			          if (result0 === null) {
			            pos = pos0;
			          }
			        }
			        return result0;
			      }
			      
			      function parse_line() {
			        var result0;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_comment();
			        if (result0 !== null) {
			          result0 = (function(offset, c) { return [[], c]})(pos1, result0);
			        }
			        if (result0 === null) {
			          pos = pos1;
			        }
			        if (result0 === null) {
			          pos1 = pos;
			          result0 = parse_instruction();
			          if (result0 !== null) {
			            result0 = (function(offset, i) { return [i.instruction,[i.comment]]})(pos1, result0);
			          }
			          if (result0 === null) {
			            pos = pos1;
			          }
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, l) { return l; })(pos0, result0);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_comment() {
			        var result0, result1, result2;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        if (input.charCodeAt(pos) === 59) {
			          result0 = ";";
			          pos++;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\";\"");
			          }
			        }
			        if (result0 !== null) {
			          result1 = [];
			          if (/^[^\n]/.test(input.charAt(pos))) {
			            result2 = input.charAt(pos);
			            pos++;
			          } else {
			            result2 = null;
			            if (reportFailures === 0) {
			              matchFailed("[^\\n]");
			            }
			          }
			          while (result2 !== null) {
			            result1.push(result2);
			            if (/^[^\n]/.test(input.charAt(pos))) {
			              result2 = input.charAt(pos);
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("[^\\n]");
			              }
			            }
			          }
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, cmt) { return cmt.join(""); })(pos0, result0[1]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_instruction() {
			        var result0, result1, result2, result3, result4, result5, result6;
			        var pos0, pos1, pos2, pos3;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_label();
			        result0 = result0 !== null ? result0 : "";
			        if (result0 !== null) {
			          result1 = [];
			          if (input.charCodeAt(pos) === 32) {
			            result2 = " ";
			            pos++;
			          } else {
			            result2 = null;
			            if (reportFailures === 0) {
			              matchFailed("\" \"");
			            }
			          }
			          while (result2 !== null) {
			            result1.push(result2);
			            if (input.charCodeAt(pos) === 32) {
			              result2 = " ";
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("\" \"");
			              }
			            }
			          }
			          if (result1 !== null) {
			            result2 = parse_operation();
			            if (result2 !== null) {
			              pos2 = pos;
			              pos3 = pos;
			              if (input.charCodeAt(pos) === 32) {
			                result3 = " ";
			                pos++;
			              } else {
			                result3 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\" \"");
			                }
			              }
			              if (result3 !== null) {
			                result4 = [];
			                if (input.charCodeAt(pos) === 32) {
			                  result5 = " ";
			                  pos++;
			                } else {
			                  result5 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\" \"");
			                  }
			                }
			                while (result5 !== null) {
			                  result4.push(result5);
			                  if (input.charCodeAt(pos) === 32) {
			                    result5 = " ";
			                    pos++;
			                  } else {
			                    result5 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\" \"");
			                    }
			                  }
			                }
			                if (result4 !== null) {
			                  result5 = parse_mode_expr();
			                  if (result5 !== null) {
			                    result3 = [result3, result4, result5];
			                  } else {
			                    result3 = null;
			                    pos = pos3;
			                  }
			                } else {
			                  result3 = null;
			                  pos = pos3;
			                }
			              } else {
			                result3 = null;
			                pos = pos3;
			              }
			              if (result3 !== null) {
			                result3 = (function(offset, expr) {return expr;})(pos2, result3[2]);
			              }
			              if (result3 === null) {
			                pos = pos2;
			              }
			              result3 = result3 !== null ? result3 : "";
			              if (result3 !== null) {
			                pos2 = pos;
			                pos3 = pos;
			                if (input.charCodeAt(pos) === 44) {
			                  result4 = ",";
			                  pos++;
			                } else {
			                  result4 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\",\"");
			                  }
			                }
			                if (result4 !== null) {
			                  result5 = [];
			                  if (input.charCodeAt(pos) === 32) {
			                    result6 = " ";
			                    pos++;
			                  } else {
			                    result6 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\" \"");
			                    }
			                  }
			                  while (result6 !== null) {
			                    result5.push(result6);
			                    if (input.charCodeAt(pos) === 32) {
			                      result6 = " ";
			                      pos++;
			                    } else {
			                      result6 = null;
			                      if (reportFailures === 0) {
			                        matchFailed("\" \"");
			                      }
			                    }
			                  }
			                  if (result5 !== null) {
			                    result6 = parse_mode_expr();
			                    if (result6 !== null) {
			                      result4 = [result4, result5, result6];
			                    } else {
			                      result4 = null;
			                      pos = pos3;
			                    }
			                  } else {
			                    result4 = null;
			                    pos = pos3;
			                  }
			                } else {
			                  result4 = null;
			                  pos = pos3;
			                }
			                if (result4 !== null) {
			                  result4 = (function(offset, expr) {return expr;})(pos2, result4[2]);
			                }
			                if (result4 === null) {
			                  pos = pos2;
			                }
			                result4 = result4 !== null ? result4 : "";
			                if (result4 !== null) {
			                  result5 = parse_comment();
			                  result5 = result5 !== null ? result5 : "";
			                  if (result5 !== null) {
			                    result0 = [result0, result1, result2, result3, result4, result5];
			                  } else {
			                    result0 = null;
			                    pos = pos1;
			                  }
			                } else {
			                  result0 = null;
			                  pos = pos1;
			                }
			              } else {
			                result0 = null;
			                pos = pos1;
			              }
			            } else {
			              result0 = null;
			              pos = pos1;
			            }
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, lbl, op, aoperand, boperand, cmt) { return { instruction: new Instruction(lbl,
			                                                    op,
			                                                    aoperand,
			                                                    boperand),
			                        comment: cmt }; })(pos0, result0[0], result0[2], result0[3], result0[4], result0[5]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_label() {
			        var result0, result1;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_label_list();
			        if (result0 !== null) {
			          if (input.charCodeAt(pos) === 58) {
			            result1 = ":";
			            pos++;
			          } else {
			            result1 = null;
			            if (reportFailures === 0) {
			              matchFailed("\":\"");
			            }
			          }
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, lbls) { return lbls; })(pos0, result0[0]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_label_list() {
			        var result0, result1, result2;
			        var pos0, pos1, pos2, pos3;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_label_name();
			        if (result0 !== null) {
			          pos2 = pos;
			          pos3 = pos;
			          if (input.charCodeAt(pos) === 32) {
			            result2 = " ";
			            pos++;
			          } else {
			            result2 = null;
			            if (reportFailures === 0) {
			              matchFailed("\" \"");
			            }
			          }
			          if (result2 !== null) {
			            result1 = [];
			            while (result2 !== null) {
			              result1.push(result2);
			              if (input.charCodeAt(pos) === 32) {
			                result2 = " ";
			                pos++;
			              } else {
			                result2 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\" \"");
			                }
			              }
			            }
			          } else {
			            result1 = null;
			          }
			          if (result1 !== null) {
			            result2 = parse_label_list();
			            if (result2 !== null) {
			              result1 = [result1, result2];
			            } else {
			              result1 = null;
			              pos = pos3;
			            }
			          } else {
			            result1 = null;
			            pos = pos3;
			          }
			          if (result1 !== null) {
			            result1 = (function(offset, l) { return l;})(pos2, result1[1]);
			          }
			          if (result1 === null) {
			            pos = pos2;
			          }
			          if (result1 === null) {
			            pos2 = pos;
			            result1 = [];
			            if (input.charCodeAt(pos) === 32) {
			              result2 = " ";
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("\" \"");
			              }
			            }
			            while (result2 !== null) {
			              result1.push(result2);
			              if (input.charCodeAt(pos) === 32) {
			                result2 = " ";
			                pos++;
			              } else {
			                result2 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\" \"");
			                }
			              }
			            }
			            if (result1 !== null) {
			              result1 = (function(offset) { return new Array(); })(pos2);
			            }
			            if (result1 === null) {
			              pos = pos2;
			            }
			          }
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, lhd, lbls) { return lbls.concat([lhd]); })(pos0, result0[0], result0[1]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_label_name() {
			        var result0, result1, result2;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
			          result0 = input.charAt(pos);
			          pos++;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("[a-zA-Z]");
			          }
			        }
			        if (result0 !== null) {
			          result1 = [];
			          if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
			            result2 = input.charAt(pos);
			            pos++;
			          } else {
			            result2 = null;
			            if (reportFailures === 0) {
			              matchFailed("[a-zA-Z0-9]");
			            }
			          }
			          while (result2 !== null) {
			            result1.push(result2);
			            if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
			              result2 = input.charAt(pos);
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("[a-zA-Z0-9]");
			              }
			            }
			          }
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, lbl) { return lbl[0] + lbl[1].join(""); })(pos0, result0);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_operation() {
			        var result0, result1, result2;
			        var pos0, pos1, pos2, pos3;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = parse_opcode();
			        if (result0 !== null) {
			          pos2 = pos;
			          pos3 = pos;
			          if (input.charCodeAt(pos) === 46) {
			            result1 = ".";
			            pos++;
			          } else {
			            result1 = null;
			            if (reportFailures === 0) {
			              matchFailed("\".\"");
			            }
			          }
			          if (result1 !== null) {
			            result2 = parse_modifier();
			            if (result2 !== null) {
			              result1 = [result1, result2];
			            } else {
			              result1 = null;
			              pos = pos3;
			            }
			          } else {
			            result1 = null;
			            pos = pos3;
			          }
			          if (result1 !== null) {
			            result1 = (function(offset, m) {return m;})(pos2, result1[1]);
			          }
			          if (result1 === null) {
			            pos = pos2;
			          }
			          result1 = result1 !== null ? result1 : "";
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, opc, mod) { return { opcode: opc.toLowerCase(), modifier: mod.toLowerCase()}; })(pos0, result0[0], result0[1]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_opcode() {
			        var result0;
			        
			        if (input.substr(pos, 3).toLowerCase() === "dat") {
			          result0 = input.substr(pos, 3);
			          pos += 3;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\"dat\"");
			          }
			        }
			        if (result0 === null) {
			          if (input.substr(pos, 3).toLowerCase() === "mov") {
			            result0 = input.substr(pos, 3);
			            pos += 3;
			          } else {
			            result0 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"mov\"");
			            }
			          }
			          if (result0 === null) {
			            if (input.substr(pos, 3).toLowerCase() === "add") {
			              result0 = input.substr(pos, 3);
			              pos += 3;
			            } else {
			              result0 = null;
			              if (reportFailures === 0) {
			                matchFailed("\"add\"");
			              }
			            }
			            if (result0 === null) {
			              if (input.substr(pos, 3).toLowerCase() === "sub") {
			                result0 = input.substr(pos, 3);
			                pos += 3;
			              } else {
			                result0 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"sub\"");
			                }
			              }
			              if (result0 === null) {
			                if (input.substr(pos, 3).toLowerCase() === "mul") {
			                  result0 = input.substr(pos, 3);
			                  pos += 3;
			                } else {
			                  result0 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\"mul\"");
			                  }
			                }
			                if (result0 === null) {
			                  if (input.substr(pos, 3).toLowerCase() === "div") {
			                    result0 = input.substr(pos, 3);
			                    pos += 3;
			                  } else {
			                    result0 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\"div\"");
			                    }
			                  }
			                  if (result0 === null) {
			                    if (input.substr(pos, 3).toLowerCase() === "mod") {
			                      result0 = input.substr(pos, 3);
			                      pos += 3;
			                    } else {
			                      result0 = null;
			                      if (reportFailures === 0) {
			                        matchFailed("\"mod\"");
			                      }
			                    }
			                    if (result0 === null) {
			                      if (input.substr(pos, 3).toLowerCase() === "jmp") {
			                        result0 = input.substr(pos, 3);
			                        pos += 3;
			                      } else {
			                        result0 = null;
			                        if (reportFailures === 0) {
			                          matchFailed("\"jmp\"");
			                        }
			                      }
			                      if (result0 === null) {
			                        if (input.substr(pos, 3).toLowerCase() === "jmz") {
			                          result0 = input.substr(pos, 3);
			                          pos += 3;
			                        } else {
			                          result0 = null;
			                          if (reportFailures === 0) {
			                            matchFailed("\"jmz\"");
			                          }
			                        }
			                        if (result0 === null) {
			                          if (input.substr(pos, 3).toLowerCase() === "jmn") {
			                            result0 = input.substr(pos, 3);
			                            pos += 3;
			                          } else {
			                            result0 = null;
			                            if (reportFailures === 0) {
			                              matchFailed("\"jmn\"");
			                            }
			                          }
			                          if (result0 === null) {
			                            if (input.substr(pos, 3).toLowerCase() === "djn") {
			                              result0 = input.substr(pos, 3);
			                              pos += 3;
			                            } else {
			                              result0 = null;
			                              if (reportFailures === 0) {
			                                matchFailed("\"djn\"");
			                              }
			                            }
			                            if (result0 === null) {
			                              if (input.substr(pos, 3).toLowerCase() === "cmp") {
			                                result0 = input.substr(pos, 3);
			                                pos += 3;
			                              } else {
			                                result0 = null;
			                                if (reportFailures === 0) {
			                                  matchFailed("\"cmp\"");
			                                }
			                              }
			                              if (result0 === null) {
			                                if (input.substr(pos, 3).toLowerCase() === "slt") {
			                                  result0 = input.substr(pos, 3);
			                                  pos += 3;
			                                } else {
			                                  result0 = null;
			                                  if (reportFailures === 0) {
			                                    matchFailed("\"slt\"");
			                                  }
			                                }
			                                if (result0 === null) {
			                                  if (input.substr(pos, 3).toLowerCase() === "spl") {
			                                    result0 = input.substr(pos, 3);
			                                    pos += 3;
			                                  } else {
			                                    result0 = null;
			                                    if (reportFailures === 0) {
			                                      matchFailed("\"spl\"");
			                                    }
			                                  }
			                                  if (result0 === null) {
			                                    if (input.substr(pos, 3).toLowerCase() === "seq") {
			                                      result0 = input.substr(pos, 3);
			                                      pos += 3;
			                                    } else {
			                                      result0 = null;
			                                      if (reportFailures === 0) {
			                                        matchFailed("\"seq\"");
			                                      }
			                                    }
			                                    if (result0 === null) {
			                                      if (input.substr(pos, 3).toLowerCase() === "sne") {
			                                        result0 = input.substr(pos, 3);
			                                        pos += 3;
			                                      } else {
			                                        result0 = null;
			                                        if (reportFailures === 0) {
			                                          matchFailed("\"sne\"");
			                                        }
			                                      }
			                                      if (result0 === null) {
			                                        if (input.substr(pos, 3).toLowerCase() === "nop") {
			                                          result0 = input.substr(pos, 3);
			                                          pos += 3;
			                                        } else {
			                                          result0 = null;
			                                          if (reportFailures === 0) {
			                                            matchFailed("\"nop\"");
			                                          }
			                                        }
			                                        if (result0 === null) {
			                                          if (input.substr(pos, 3).toLowerCase() === "ldp") {
			                                            result0 = input.substr(pos, 3);
			                                            pos += 3;
			                                          } else {
			                                            result0 = null;
			                                            if (reportFailures === 0) {
			                                              matchFailed("\"ldp\"");
			                                            }
			                                          }
			                                          if (result0 === null) {
			                                            if (input.substr(pos, 3).toLowerCase() === "stp") {
			                                              result0 = input.substr(pos, 3);
			                                              pos += 3;
			                                            } else {
			                                              result0 = null;
			                                              if (reportFailures === 0) {
			                                                matchFailed("\"stp\"");
			                                              }
			                                            }
			                                            if (result0 === null) {
			                                              if (input.substr(pos, 3).toLowerCase() === "org") {
			                                                result0 = input.substr(pos, 3);
			                                                pos += 3;
			                                              } else {
			                                                result0 = null;
			                                                if (reportFailures === 0) {
			                                                  matchFailed("\"org\"");
			                                                }
			                                              }
			                                              if (result0 === null) {
			                                                if (input.substr(pos, 3).toLowerCase() === "equ") {
			                                                  result0 = input.substr(pos, 3);
			                                                  pos += 3;
			                                                } else {
			                                                  result0 = null;
			                                                  if (reportFailures === 0) {
			                                                    matchFailed("\"equ\"");
			                                                  }
			                                                }
			                                                if (result0 === null) {
			                                                  if (input.substr(pos, 3).toLowerCase() === "end") {
			                                                    result0 = input.substr(pos, 3);
			                                                    pos += 3;
			                                                  } else {
			                                                    result0 = null;
			                                                    if (reportFailures === 0) {
			                                                      matchFailed("\"end\"");
			                                                    }
			                                                  }
			                                                }
			                                              }
			                                            }
			                                          }
			                                        }
			                                      }
			                                    }
			                                  }
			                                }
			                              }
			                            }
			                          }
			                        }
			                      }
			                    }
			                  }
			                }
			              }
			            }
			          }
			        }
			        return result0;
			      }
			      
			      function parse_modifier() {
			        var result0;
			        
			        if (input.substr(pos, 2).toLowerCase() === "ab") {
			          result0 = input.substr(pos, 2);
			          pos += 2;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\"ab\"");
			          }
			        }
			        if (result0 === null) {
			          if (input.substr(pos, 2).toLowerCase() === "ba") {
			            result0 = input.substr(pos, 2);
			            pos += 2;
			          } else {
			            result0 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"ba\"");
			            }
			          }
			          if (result0 === null) {
			            if (input.substr(pos, 1).toLowerCase() === "a") {
			              result0 = input.substr(pos, 1);
			              pos++;
			            } else {
			              result0 = null;
			              if (reportFailures === 0) {
			                matchFailed("\"a\"");
			              }
			            }
			            if (result0 === null) {
			              if (input.substr(pos, 1).toLowerCase() === "b") {
			                result0 = input.substr(pos, 1);
			                pos++;
			              } else {
			                result0 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"b\"");
			                }
			              }
			              if (result0 === null) {
			                if (input.substr(pos, 1).toLowerCase() === "f") {
			                  result0 = input.substr(pos, 1);
			                  pos++;
			                } else {
			                  result0 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\"f\"");
			                  }
			                }
			                if (result0 === null) {
			                  if (input.substr(pos, 1).toLowerCase() === "x") {
			                    result0 = input.substr(pos, 1);
			                    pos++;
			                  } else {
			                    result0 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\"x\"");
			                    }
			                  }
			                  if (result0 === null) {
			                    if (input.substr(pos, 1).toLowerCase() === "i") {
			                      result0 = input.substr(pos, 1);
			                      pos++;
			                    } else {
			                      result0 = null;
			                      if (reportFailures === 0) {
			                        matchFailed("\"i\"");
			                      }
			                    }
			                  }
			                }
			              }
			            }
			          }
			        }
			        return result0;
			      }
			      
			      function parse_mode_expr() {
			        var result0, result1;
			        var pos0;
			        
			        pos0 = pos;
			        result0 = parse_mode();
			        result0 = result0 !== null ? result0 : "";
			        if (result0 !== null) {
			          result1 = parse_expr();
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos0;
			          }
			        } else {
			          result0 = null;
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_mode() {
			        var result0;
			        
			        if (input.charCodeAt(pos) === 35) {
			          result0 = "#";
			          pos++;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\"#\"");
			          }
			        }
			        if (result0 === null) {
			          if (input.charCodeAt(pos) === 36) {
			            result0 = "$";
			            pos++;
			          } else {
			            result0 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"$\"");
			            }
			          }
			          if (result0 === null) {
			            if (input.charCodeAt(pos) === 64) {
			              result0 = "@";
			              pos++;
			            } else {
			              result0 = null;
			              if (reportFailures === 0) {
			                matchFailed("\"@\"");
			              }
			            }
			            if (result0 === null) {
			              if (input.charCodeAt(pos) === 60) {
			                result0 = "<";
			                pos++;
			              } else {
			                result0 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"<\"");
			                }
			              }
			              if (result0 === null) {
			                if (input.charCodeAt(pos) === 62) {
			                  result0 = ">";
			                  pos++;
			                } else {
			                  result0 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\">\"");
			                  }
			                }
			                if (result0 === null) {
			                  if (input.charCodeAt(pos) === 42) {
			                    result0 = "*";
			                    pos++;
			                  } else {
			                    result0 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\"*\"");
			                    }
			                  }
			                  if (result0 === null) {
			                    if (input.charCodeAt(pos) === 123) {
			                      result0 = "{";
			                      pos++;
			                    } else {
			                      result0 = null;
			                      if (reportFailures === 0) {
			                        matchFailed("\"{\"");
			                      }
			                    }
			                    if (result0 === null) {
			                      if (input.charCodeAt(pos) === 125) {
			                        result0 = "}";
			                        pos++;
			                      } else {
			                        result0 = null;
			                        if (reportFailures === 0) {
			                          matchFailed("\"}\"");
			                        }
			                      }
			                    }
			                  }
			                }
			              }
			            }
			          }
			        }
			        return result0;
			      }
			      
			      function parse_expr() {
			        var result0, result1, result2;
			        var pos0;
			        
			        pos0 = pos;
			        result0 = parse_term();
			        if (result0 !== null) {
			          result1 = parse_expr_op();
			          if (result1 !== null) {
			            result2 = parse_expr();
			            if (result2 !== null) {
			              result0 = [result0, result1, result2];
			            } else {
			              result0 = null;
			              pos = pos0;
			            }
			          } else {
			            result0 = null;
			            pos = pos0;
			          }
			        } else {
			          result0 = null;
			          pos = pos0;
			        }
			        if (result0 === null) {
			          result0 = parse_term();
			        }
			        return result0;
			      }
			      
			      function parse_expr_op() {
			        var result0, result1, result2, result3;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        result0 = [];
			        if (input.charCodeAt(pos) === 32) {
			          result1 = " ";
			          pos++;
			        } else {
			          result1 = null;
			          if (reportFailures === 0) {
			            matchFailed("\" \"");
			          }
			        }
			        while (result1 !== null) {
			          result0.push(result1);
			          if (input.charCodeAt(pos) === 32) {
			            result1 = " ";
			            pos++;
			          } else {
			            result1 = null;
			            if (reportFailures === 0) {
			              matchFailed("\" \"");
			            }
			          }
			        }
			        if (result0 !== null) {
			          if (input.charCodeAt(pos) === 42) {
			            result1 = "*";
			            pos++;
			          } else {
			            result1 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"*\"");
			            }
			          }
			          if (result1 === null) {
			            if (input.charCodeAt(pos) === 47) {
			              result1 = "/";
			              pos++;
			            } else {
			              result1 = null;
			              if (reportFailures === 0) {
			                matchFailed("\"/\"");
			              }
			            }
			            if (result1 === null) {
			              if (input.charCodeAt(pos) === 43) {
			                result1 = "+";
			                pos++;
			              } else {
			                result1 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\"+\"");
			                }
			              }
			              if (result1 === null) {
			                if (input.charCodeAt(pos) === 45) {
			                  result1 = "-";
			                  pos++;
			                } else {
			                  result1 = null;
			                  if (reportFailures === 0) {
			                    matchFailed("\"-\"");
			                  }
			                }
			                if (result1 === null) {
			                  if (input.charCodeAt(pos) === 37) {
			                    result1 = "%";
			                    pos++;
			                  } else {
			                    result1 = null;
			                    if (reportFailures === 0) {
			                      matchFailed("\"%\"");
			                    }
			                  }
			                }
			              }
			            }
			          }
			          if (result1 !== null) {
			            result2 = [];
			            if (input.charCodeAt(pos) === 32) {
			              result3 = " ";
			              pos++;
			            } else {
			              result3 = null;
			              if (reportFailures === 0) {
			                matchFailed("\" \"");
			              }
			            }
			            while (result3 !== null) {
			              result2.push(result3);
			              if (input.charCodeAt(pos) === 32) {
			                result3 = " ";
			                pos++;
			              } else {
			                result3 = null;
			                if (reportFailures === 0) {
			                  matchFailed("\" \"");
			                }
			              }
			            }
			            if (result2 !== null) {
			              result0 = [result0, result1, result2];
			            } else {
			              result0 = null;
			              pos = pos1;
			            }
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, eop) { return eop; })(pos0, result0[1]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      function parse_term() {
			        var result0, result1, result2;
			        var pos0;
			        
			        pos0 = pos;
			        if (input.charCodeAt(pos) === 40) {
			          result0 = "(";
			          pos++;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\"(\"");
			          }
			        }
			        if (result0 !== null) {
			          result1 = parse_expr();
			          if (result1 !== null) {
			            if (input.charCodeAt(pos) === 41) {
			              result2 = ")";
			              pos++;
			            } else {
			              result2 = null;
			              if (reportFailures === 0) {
			                matchFailed("\")\"");
			              }
			            }
			            if (result2 !== null) {
			              result0 = [result0, result1, result2];
			            } else {
			              result0 = null;
			              pos = pos0;
			            }
			          } else {
			            result0 = null;
			            pos = pos0;
			          }
			        } else {
			          result0 = null;
			          pos = pos0;
			        }
			        if (result0 === null) {
			          result0 = parse_label_name();
			          if (result0 === null) {
			            result0 = parse_number();
			          }
			        }
			        return result0;
			      }
			      
			      function parse_number() {
			        var result0;
			        
			        result0 = parse_signed_integer();
			        if (result0 === null) {
			          result0 = parse_natural_number();
			        }
			        return result0;
			      }
			      
			      function parse_signed_integer() {
			        var result0, result1;
			        var pos0, pos1;
			        
			        pos0 = pos;
			        pos1 = pos;
			        if (input.charCodeAt(pos) === 43) {
			          result0 = "+";
			          pos++;
			        } else {
			          result0 = null;
			          if (reportFailures === 0) {
			            matchFailed("\"+\"");
			          }
			        }
			        if (result0 !== null) {
			          result1 = parse_natural_number();
			          if (result1 !== null) {
			            result0 = [result0, result1];
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			        } else {
			          result0 = null;
			          pos = pos1;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, num) { return num; })(pos0, result0[1]);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        if (result0 === null) {
			          pos0 = pos;
			          pos1 = pos;
			          if (input.charCodeAt(pos) === 45) {
			            result0 = "-";
			            pos++;
			          } else {
			            result0 = null;
			            if (reportFailures === 0) {
			              matchFailed("\"-\"");
			            }
			          }
			          if (result0 !== null) {
			            result1 = parse_natural_number();
			            if (result1 !== null) {
			              result0 = [result0, result1];
			            } else {
			              result0 = null;
			              pos = pos1;
			            }
			          } else {
			            result0 = null;
			            pos = pos1;
			          }
			          if (result0 !== null) {
			            result0 = (function(offset, num) { return -num; })(pos0, result0[1]);
			          }
			          if (result0 === null) {
			            pos = pos0;
			          }
			        }
			        return result0;
			      }
			      
			      function parse_natural_number() {
			        var result0, result1;
			        var pos0;
			        
			        pos0 = pos;
			        if (/^[0-9]/.test(input.charAt(pos))) {
			          result1 = input.charAt(pos);
			          pos++;
			        } else {
			          result1 = null;
			          if (reportFailures === 0) {
			            matchFailed("[0-9]");
			          }
			        }
			        if (result1 !== null) {
			          result0 = [];
			          while (result1 !== null) {
			            result0.push(result1);
			            if (/^[0-9]/.test(input.charAt(pos))) {
			              result1 = input.charAt(pos);
			              pos++;
			            } else {
			              result1 = null;
			              if (reportFailures === 0) {
			                matchFailed("[0-9]");
			              }
			            }
			          }
			        } else {
			          result0 = null;
			        }
			        if (result0 !== null) {
			          result0 = (function(offset, num) { return parseInt(num.join(""), 10); })(pos0, result0);
			        }
			        if (result0 === null) {
			          pos = pos0;
			        }
			        return result0;
			      }
			      
			      
			      function cleanupExpected(expected) {
			        expected.sort();
			        
			        var lastExpected = null;
			        var cleanExpected = [];
			        for (var i = 0; i < expected.length; i++) {
			          if (expected[i] !== lastExpected) {
			            cleanExpected.push(expected[i]);
			            lastExpected = expected[i];
			          }
			        }
			        return cleanExpected;
			      }
			      
			      function computeErrorPosition() {
			        /*
			         * The first idea was to use |String.split| to break the input up to the
			         * error position along newlines and derive the line and column from
			         * there. However IE's |split| implementation is so broken that it was
			         * enough to prevent it.
			         */
			        
			        var line = 1;
			        var column = 1;
			        var seenCR = false;
			        
			        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
			          var ch = input.charAt(i);
			          if (ch === "\n") {
			            if (!seenCR) { line++; }
			            column = 1;
			            seenCR = false;
			          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
			            line++;
			            column = 1;
			            seenCR = true;
			          } else {
			            column++;
			            seenCR = false;
			          }
			        }
			        
			        return { line: line, column: column };
			      }
			      
			      
			          var Instruction = require("./instruction.js");
			      
			      
			      var result = parseFunctions[startRule]();
			      
			      /*
			       * The parser is now in one of the following three states:
			       *
			       * 1. The parser successfully parsed the whole input.
			       *
			       *    - |result !== null|
			       *    - |pos === input.length|
			       *    - |rightmostFailuresExpected| may or may not contain something
			       *
			       * 2. The parser successfully parsed only a part of the input.
			       *
			       *    - |result !== null|
			       *    - |pos < input.length|
			       *    - |rightmostFailuresExpected| may or may not contain something
			       *
			       * 3. The parser did not successfully parse any part of the input.
			       *
			       *   - |result === null|
			       *   - |pos === 0|
			       *   - |rightmostFailuresExpected| contains at least one failure
			       *
			       * All code following this comment (including called functions) must
			       * handle these states.
			       */
			      if (result === null || pos !== input.length) {
			        var offset = Math.max(pos, rightmostFailuresPos);
			        var found = offset < input.length ? input.charAt(offset) : null;
			        var errorPosition = computeErrorPosition();
			        
			        throw new this.SyntaxError(
			          cleanupExpected(rightmostFailuresExpected),
			          found,
			          offset,
			          errorPosition.line,
			          errorPosition.column
			        );
			      }
			      
			      return result;
			    },
			    
			    /* Returns the parser source code. */
			    toSource: function() { return this._source; }
			  };
			  
			  /* Thrown when a parser encounters a syntax error. */
			  
			  result.SyntaxError = function(expected, found, offset, line, column) {
			    function buildMessage(expected, found) {
			      var expectedHumanized, foundHumanized;
			      
			      switch (expected.length) {
			        case 0:
			          expectedHumanized = "end of input";
			          break;
			        case 1:
			          expectedHumanized = expected[0];
			          break;
			        default:
			          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
			            + " or "
			            + expected[expected.length - 1];
			      }
			      
			      foundHumanized = found ? quote(found) : "end of input";
			      
			      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
			    }
			    
			    this.name = "SyntaxError";
			    this.expected = expected;
			    this.found = found;
			    this.message = buildMessage(expected, found);
			    this.offset = offset;
			    this.line = line;
			    this.column = column;
			  };
			  
			  result.SyntaxError.prototype = Error.prototype;
			  
			  return result;
			})();
		},
		"redcode-asm.js": function (exports, module, require) {
			module.exports = (function(){
			    var redcodeParser = require('./redcode-asm-parser.js');
			    

			    function Program(name, author, version, date, strict94, origin, instructions)
			    {
			        this.name = name;
			        this.author = author;
			        this.date = date;
			        this.version = version;
			        this.strict94 = strict94;
			        this.instructions = instructions;
			        this.origin = evaluateExpression(origin);

			        this.loadFileString = function()
			        {
			            var lines = [";redcode", "org " + origin];

			            for(var i=0;i<this.instructions.length;i++)
			            {
			                lines.push(this.instructions[i].toString());
			            }

			            return lines.join("\n");
			        };
			    }

			    function reduceExpression(lineNum, labels, definitions, expression)
			    {
			        if(typeof expression != 'undefined' && typeof expression != 'number')
			        {
			            if(typeof expression == 'string')
			            {
			                if(_.has(definitions, expression))
			                {
			                    return reduceExpression(lineNum, labels, definitions,
			                        definitions[expression]);
			                }
			                else if(_.has(labels, expression))
			                {
			                    return ["(" + (labels[expression]-lineNum) + ")"];
			                }
			                else
			                {
			                    throw new Error("Label \"" + expression + "\" not found.");
			                }
			            }
			            else if(typeof expression == 'object')
			            {
			                // Flatten the expression
			                expression = _.flatten(expression);
			                // Reduce everything except operators and parantheses
			                expression = _.map(expression, function(tok)
			                {
			                    if(_.contains(["*","/","-","+","%","(",")"],tok))
			                    {
			                        return tok;
			                    }
			                    else
			                    {
			                        return reduceExpression(lineNum, labels, definitions,tok);
			                    }
			                });
			                // Flatten again to remove replacements
			                expression = _.flatten(expression);
			            }
			        }
			        return expression;
			    }

			    function evaluateExpression(expression)
			    {
			        if(typeof expression != 'undefined' && typeof expression != 'number')
			            return eval(expression.join(""));
			        return expression;
			    }

			    function reduceInstructions(instructions)
			    {
			        // Filter pseudo opcodes
			        var origin = 0;
			        var end = instructions.length;
			        var filteredInstructions = [];
			        var definitions = {};
			        var i, inst;
			        for (i=0; i<instructions.length; i++)
			        {
			            inst = instructions[i];
			            if(inst.opcode == "org")
			            {
			                origin = inst.aoperand[1];
			            }
			            else if(inst.opcode == "equ")
			            {
			                if(inst.labels.length && inst.aoperand[1])
			                {
			                    _.forEach(inst.labels, function(lbl)
			                        { definitions[lbl] = inst.aoperand[1]; });
			                }
			                else
			                {
			                    // Todo throw exception here
			                    throw new Error("Could not find label or definition of equ.");
			                }
			            }
			            else if(inst.opcode == "end")
			            {
			                if(inst.aoperand)
			                    origin = inst.aoperand[1];
			                break;
			            }
			            else
			            {
			                filteredInstructions.push(inst);
			            }
			        }
			        instructions = filteredInstructions;

			        // Generate dictionary of labels
			        labels = {};
			        for (i=instructions.length-1; i>=0; i--)
			        {
			            inst = instructions[i];
			            if(inst.labels.length)
			                _.forEach(inst.labels, function(lbl) { labels[lbl] = i; });
			        }

			        // Now we're ready to reduce the instructions
			        for (i=instructions.length-1; i>=0; i--)
			        {
			            // Remove the labels
			            instructions[i].labels = [];

			            // Reduce the expressions
			            instructions[i].aoperand[1] =
			                evaluateExpression(reduceExpression(i, labels, definitions,
			                    instructions[i].aoperand[1]));
			            instructions[i].boperand[1] =
			                evaluateExpression(reduceExpression(i, labels, definitions,
			                    instructions[i].boperand[1]));
			        }

			        origin = reduceExpression(0, labels, definitions, origin);

			        return {origin: origin, instructions: instructions};
			    }

			    function validate(program)
			    {
			        // Checks if the program is a valid assembled redcode program
			        // a.k.a redcode load file

			        // Check for each instruction whether:
			        // * labels are empty
			        // * fields are numeric
			        // * only valid load file opcodes are used
			        program.instructions = _.map(program.instructions, function(inst)
			        {
			            if(inst.labels.length)
			                throw new Error("Labels not allowed in load file.");

			            if(typeof inst.aoperand[1] != 'number' && typeof inst.aoperand[1] != 'undefined')
			                throw new Error("Labels & expressions not allowed in load file.");

			            if(typeof inst.boperand[1] != 'number' && typeof inst.boperand[1] != 'undefined')
			                throw new Error("Labels & expressions not allowed in load file.");

			            if(inst.boperand && !inst.aoperand)
			                throw new Error("B field given without A field.");

			            switch(inst.opcode)
			            {
			             case "dat":
			                 if(typeof inst.boperand[1] == 'undefined')
			                 {
			                    inst.boperand = inst.aoperand;
			                    inst.aoperand = ["#",0];
			                 }
			                 break;
			             case "mov":
			             case "add":
			             case "sub":
			             case "mul":
			             case "div":
			             case "mod":
			             case "jmp":
			             case "jmz":
			             case "jmn":
			             case "djn":
			             case "cmp":
			             case "slt":
			             case "spl":
			             case "seq":
			             case "sne":
			             case "nop":
			             case "ldp":
			             case "stp":
			                if(typeof inst.boperand[1] == 'undefined')
			                {
			                    inst.boperand = ["#",0];
			                }
			                break;
			             case "org":
			                throw new Error("Org pseudoopcode should not reach validation. Contact the developer and file a bug report.");
			             case "equ":
			                throw new Error("Equ pseudoopcode not allowed in load file.");
			             case "end":
			                throw new Error("End pseudoopcode not allowed in load file.");
			            }

			            if(typeof inst.aoperand[1] == 'undefined')
			            {
			                inst.aoperand = ["#",0];
			            }

			            if(program.strict94)
			            {
			                if(_.contains(["snq","nop","ldp","stp"], inst.opcode))
			                    throw new Error("Strict mode does not allow the opcode \"" + inst.opcode + "\"");

			                if(_.contains(["*","{", "}"], inst.aoperand[0]))
			                    throw new Error("Strict mode does not allow the address mode \"" + inst.aoperand[0] + "\"");

			                if(_.contains(["*","{", "}"], inst.boperand[0]))
			                    throw new Error("Strict mode does not allow the address mode \"" + inst.boperand[0] + "\"");
			            }

			            return inst;
			        });

			        return program;
			    }

			    String.prototype.beginsWith = function(str)
			    {
			        return this.substring(0,str.length) == str;
			    };

			    var redcode =
			    {
			        parser: redcodeParser,

			        assembleString: function(programString, loadFile, name, author, version, date)
			        {
			            loadFile = typeof loadFile !== 'undefined' ? loadFile : false;
			            // Find the beginning of the program
			            var lines = programString.split("\n");
			            var line;
			            do
			            {
			                line = _.head(lines);
			                lines = _.tail(lines);
			            } while(!line.beginsWith(";redcode"));

			            programString = lines.join("\n");

			            var parsed = _.unzip(redcode.parser.parse(programString));
			            var comments = _.filter(parsed[1], function(x) { return x != "";});
			            var instructions = _.filter(parsed[0], function(x) { return x != "";});
			            // Reduce the instructions (remove labels & eval expressions)
			            var reduced = {};
			            if(!loadFile)
			            {
			                reduced = reduceInstructions(instructions);
			            }
			            else
			            {
			                var origin = 0;
			                var filteredInstructions = [];
			                var i, inst;
			                for (i=0; i<instructions.length; i++)
			                {
			                    inst = instructions[i];
			                    if(inst.opcode == "org")
			                    {
			                        if(typeof inst.aoperand[1] != 'number')
			                            throw new Error("Origin needs to be numeric.");
			                        origin = inst.aoperand[1];
			                    }
			                    else
			                    {
			                        filteredInstructions.push(inst);
			                    }
			                }
			                instructions = filteredInstructions;

			                reduced = {origin: origin, instructions: instructions};
			            }



			            var strict94 = false;
			            name = typeof name !== 'undefined' ? name : "Untitled";
			            author = typeof author !== 'undefined' ? author : "Anonymous";
			            version = typeof version !== 'undefined' ? version : "1";
			            date = (new Date()).toDateString();
			            // Parse metadata comments
			            _.forEach(comments, function(cmt) {
			                if(cmt.toString().beginsWith("name "))
			                {
			                    name = _.drop(cmt, "name ".length);
			                }
			                if(cmt.toString().beginsWith("author "))
			                {
			                    author = _.drop(cmt, "author ".length);
			                }
			                if(cmt.toString().beginsWith("date "))
			                {
			                    date = _.drop(cmt, "date ".length);
			                }
			                if(cmt.toString().beginsWith("version "))
			                {
			                    version = _.drop(cmt, "version ".length);
			                }
			                if(cmt.toString() == "strict94")
			                {
			                    strict94 = true;
			                }
			            });

			            var result = new Program(name, author, version, date, strict94, reduced.origin, reduced.instructions);
			            return validate(result);
			        }
			    };
			    return redcode;
			})();
		}
	},
	"sprintf-js": {
		":mainpath:": "src/sprintf.js",
		"src": {
			"sprintf.js": function (exports, module, require) {
				/*! sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */
				
				(function(ctx) {
					var sprintf = function() {
						if (!sprintf.cache.hasOwnProperty(arguments[0])) {
							sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
						}
						return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
					};
				
					sprintf.format = function(parse_tree, argv) {
						var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
						for (i = 0; i < tree_length; i++) {
							node_type = get_type(parse_tree[i]);
							if (node_type === 'string') {
								output.push(parse_tree[i]);
							}
							else if (node_type === 'array') {
								match = parse_tree[i]; // convenience purposes only
								if (match[2]) { // keyword argument
									arg = argv[cursor];
									for (k = 0; k < match[2].length; k++) {
										if (!arg.hasOwnProperty(match[2][k])) {
											throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
										}
										arg = arg[match[2][k]];
									}
								}
								else if (match[1]) { // positional argument (explicit)
									arg = argv[match[1]];
								}
								else { // positional argument (implicit)
									arg = argv[cursor++];
								}
				
								if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
									throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
								}
								switch (match[8]) {
									case 'b': arg = arg.toString(2); break;
									case 'c': arg = String.fromCharCode(arg); break;
									case 'd': arg = parseInt(arg, 10); break;
									case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
									case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
									case 'o': arg = arg.toString(8); break;
									case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
									case 'u': arg = arg >>> 0; break;
									case 'x': arg = arg.toString(16); break;
									case 'X': arg = arg.toString(16).toUpperCase(); break;
								}
								arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
								pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
								pad_length = match[6] - String(arg).length;
								pad = match[6] ? str_repeat(pad_character, pad_length) : '';
								output.push(match[5] ? arg + pad : pad + arg);
							}
						}
						return output.join('');
					};
				
					sprintf.cache = {};
				
					sprintf.parse = function(fmt) {
						var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
						while (_fmt) {
							if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
								parse_tree.push(match[0]);
							}
							else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
								parse_tree.push('%');
							}
							else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
								if (match[2]) {
									arg_names |= 1;
									var field_list = [], replacement_field = match[2], field_match = [];
									if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
										field_list.push(field_match[1]);
										while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
											if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
												field_list.push(field_match[1]);
											}
											else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
												field_list.push(field_match[1]);
											}
											else {
												throw('[sprintf] huh?');
											}
										}
									}
									else {
										throw('[sprintf] huh?');
									}
									match[2] = field_list;
								}
								else {
									arg_names |= 2;
								}
								if (arg_names === 3) {
									throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
								}
								parse_tree.push(match);
							}
							else {
								throw('[sprintf] huh?');
							}
							_fmt = _fmt.substring(match[0].length);
						}
						return parse_tree;
					};
				
					var vsprintf = function(fmt, argv, _argv) {
						_argv = argv.slice(0);
						_argv.splice(0, 0, fmt);
						return sprintf.apply(null, _argv);
					};
				
					/**
					 * helpers
					 */
					function get_type(variable) {
						return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
					}
				
					function str_repeat(input, multiplier) {
						for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
						return output.join('');
					}
				
					/**
					 * export to either browser or node.js
					 */
					ctx.sprintf = sprintf;
					ctx.vsprintf = vsprintf;
				})(typeof exports != "undefined" ? exports : window);
			}
		}
	}
})("client/frontend");
